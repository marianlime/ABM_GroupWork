from Second_Draft_Trading import Trader, NoiseTrader
import random
import numpy as np
import matplotlib.pyplot as plt


def generate_signal():
    """
    Mock signal generator.
    You can replace this with Marian's signal generator later.
    """
    # Example: signals centered around 1.0 (i.e., "fair value multiplier")
    # >1 implies bullish, <1 implies bearish
    return random.gauss(mu=1.0, sigma=0.03)


def action_from_order(order: dict) -> str:
    """Return 'buy'/'sell'/'hold' based on your order dict structure."""
    if order.get("Buy", 0.0) == 1.0:
        return "buy"
    if order.get("Sell", 0.0) == 1.0:
        return "sell"
    return "hold"


def run_one_simulation(
    T: int = 100,
    initial_price: float = 100.0,
    cash: float = 5000.0,
    shares: float = 50.0,
    info_param: float = 0.05,
    price_impact: float = 0.02,
    seed: int | None = None
):
    """
    Runs one simulation path of length T and returns:
      - prices: list[float] length T
      - counts: dict with buy/sell/hold totals
      - inventories: dict trader_id -> list[float] length T
      - signals: list[float] length T (signals used for informed + ZI in this mock)
    """
    if seed is not None:
        random.seed(seed)
        np.random.seed(seed)

    # Create traders fresh each simulation (important so state resets)
    t1 = Trader(uaid=1, cash=cash, shares=shares, info_param=info_param, trader_type="signal_following")
    t2 = Trader(uaid=2, cash=cash, shares=shares, trader_type="zi")
    t3 = NoiseTrader(uaid=3, cash=cash, shares=shares)

    traders = [t1, t2, t3]

    price = initial_price
    prices = []
    signals = []

    counts = {"buy": 0, "sell": 0, "hold": 0}

    # Inventory history (track shares over time)
    inventories = {1: [], 2: [], 3: []}

    for _ in range(T):
        # Generate a new signal each timestep (mock)
        signal_t = generate_signal()
        signals.append(signal_t)

        # Build orders
        order1 = t1.place_order(signal=signal_t, value=price)
        order2 = t2.place_order(signal=signal_t, value=price)  # ZI may ignore, but signature expects it
        order3 = t3.place_order(value=price)                   # noise trader has no signal arg

        all_orders = [order1, order2, order3]

        # Count actions + approximate net order imbalance for a simple "price impact" rule
        net_imbalance = 0.0  # buy qty - sell qty
        for order in all_orders:
            act = action_from_order(order)
            qty = float(order.get("Quantity", 0.0) or 0.0)

            counts[act] += 1

            if act == "buy":
                net_imbalance += qty
            elif act == "sell":
                net_imbalance -= qty

        # Simple price update: move price in direction of net order flow
        # (This is intentionally a mock dynamic—good enough for a LinkedIn visual.)
        price = max(0.01, price * (1.0 + price_impact * (net_imbalance / 100.0)))
        prices.append(price)

        # Track inventories
        inventories[1].append(t1.shares)
        inventories[2].append(t2.shares)
        inventories[3].append(t3.shares)

    return prices, counts, inventories, signals


def run_monte_carlo(n_sims: int = 100, T: int = 100, initial_price: float = 100.0, seed: int = 42):
    """
    Runs n_sims simulations and aggregates results for plotting.
    Returns:
      - price_paths: np.ndarray shape (n_sims, T)
      - total_counts: dict with buy/sell/hold totals across all sims
      - inv_paths: dict trader_id -> np.ndarray shape (n_sims, T)
      - all_signals: np.ndarray shape (n_sims*T,)
    """
    random.seed(seed)
    np.random.seed(seed)

    price_paths = np.zeros((n_sims, T))
    inv_paths = {1: np.zeros((n_sims, T)), 2: np.zeros((n_sims, T)), 3: np.zeros((n_sims, T))}
    all_signals = []

    total_counts = {"buy": 0, "sell": 0, "hold": 0}

    for i in range(n_sims):
        prices, counts, inventories, signals = run_one_simulation(
            T=T,
            initial_price=initial_price,
            seed=seed + i  # vary seed per run
        )

        price_paths[i, :] = np.array(prices)

        for k in total_counts:
            total_counts[k] += counts[k]

        for tid in inv_paths:
            inv_paths[tid][i, :] = np.array(inventories[tid])

        all_signals.extend(signals)

    return price_paths, total_counts, inv_paths, np.array(all_signals)


def plot_results(price_paths, total_counts, inv_paths, all_signals):
    """
    Produces 4 professional plots (separate figures).
    """
    n_sims, T = price_paths.shape
    t = np.arange(T)

    # 1) Price evolution: mean + 10–90% band
    mean_price = price_paths.mean(axis=0)
    p10 = np.percentile(price_paths, 10, axis=0)
    p90 = np.percentile(price_paths, 90, axis=0)

    plt.figure(figsize=(9, 4))
    plt.plot(t, mean_price, label="Mean price")
    plt.fill_between(t, p10, p90, alpha=0.2, label="10–90% band")
    plt.title(f"Price Evolution (Monte Carlo, n={n_sims})")
    plt.xlabel("Time step")
    plt.ylabel("Price")
    plt.legend()
    plt.tight_layout()

    # 2) Buy/Sell/Hold frequency (across all sims & timesteps)
    plt.figure(figsize=(6, 4))
    plt.bar(["Buy", "Sell", "Hold"], [total_counts["buy"], total_counts["sell"], total_counts["hold"]])
    plt.title("Action Frequency (All Simulations)")
    plt.ylabel("Count")
    plt.tight_layout()

    # 3) Inventory over time: mean inventory per trader
    plt.figure(figsize=(9, 4))
    for tid in sorted(inv_paths.keys()):
        plt.plot(t, inv_paths[tid].mean(axis=0), label=f"Trader {tid} mean inventory")
    plt.title("Inventory Over Time (Mean Across Simulations)")
    plt.xlabel("Time step")
    plt.ylabel("Shares held")
    plt.legend()
    plt.tight_layout()

    # 4) Signal distribution
    plt.figure(figsize=(7, 4))
    plt.hist(all_signals, bins=30)
    plt.title("Signal Distribution")
    plt.xlabel("Signal value")
    plt.ylabel("Frequency")
    plt.tight_layout()

    plt.show()


if __name__ == "__main__":
    # Run 100 simulations of 100 timesteps each
    price_paths, total_counts, inv_paths, all_signals = run_monte_carlo(
        n_sims=100,
        T=100,
        initial_price=100.0,
        seed=42
    )

    plot_results(price_paths, total_counts, inv_paths, all_signals)